#!/usr/bin/env python
# -*- coding: UTF-8 -*-

#
# This utility is part of the DecoyDB (working title) project
#
# Author: Stephen Leong Koan
#
# Copyright (C) 2013 Université de Montréal
#

"""
Command-line utility to filter MC-Fold result to make sure there is no stem on the complementary side of each mature
"""

import os
import argparse
import cPickle

def extract_seq(input_file):
    """ Extract the fasta and convert it as a dict with key=seq_name, value=sequence """
    result_dict = dict()
    with open(input_file, 'rb') as input:
        list_lines = input.readlines()
        i = 0
        while i < len(list_lines):
            line = list_lines[i]
            if line.startswith(">"):
                header = line.strip()
                j = i+1
                seq = ""
                while j < len(list_lines):
                    curr_line = list_lines[j]
                    if curr_line.startswith(">"):
                        break
                    else:
                        seq += curr_line.strip()
                        j += 1
                result_dict[header] = seq
                i = j
            else:
                i += 1
    return result_dict

def validate_structure(structure, range_5p=[], range_3p=[]):
    list_opener = []

    verdict = True

    set_stems_5p = set()
    set_stems_3p = set()

    i = 0
    curr_stem_index = 1
    list_stem_end = []
    # separate in stems
    while i < len(structure):
        if structure[i] == "(":
            list_opener.append(i)
        elif structure[i] == ")":
            list_open = []
            list_close = []
            while i < len(structure):
                if structure[i] == ")":
                    opener = list_opener.pop(-1)
                    list_open.append(opener)
                    list_close.append(i)
                    if list_opener and list_opener[-1] in list_stem_end:
                        list_stem_end.append(list_opener[-1])
                        break
                elif structure[i] == "(":
                    if list_opener:
                        list_stem_end.append(list_opener[-1])
                    i -= 1
                    break
                i += 1

            range_open = range(min(list_open), max(list_open)+1)
            range_close = range(min(list_close), max(list_close)+1)

            if range_5p:
                for elem in range_5p:
                    if elem in range_open:
                        set_stems_5p.add(str(curr_stem_index))
                    if elem in range_close:
                        verdict = False
                        break

            if range_3p:
                for elem in range_3p:
                    if elem in range_close:
                        set_stems_3p.add(str(curr_stem_index))
                    if elem in range_open:
                        verdict = False
                        break

            curr_stem_index += 1

        i += 1

    if set_stems_3p and set_stems_5p:
        # if the 3p mature is not on the same stem as 3p, we have a problem
        if set_stems_3p != set_stems_5p:
            verdict = False
    # if a mature is not on the same stem, we have a problem too
    if len(set_stems_3p) > 1 or len(set_stems_5p) > 1:
        verdict = False

    return verdict


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--digested_data',
                        action="store",
                        required=True,
                        dest="digested_data",
                        help="The pickle file generated by 1_organize_precursor_mature.py")
    parser.add_argument('--mcfold_output_dir',
                        action="store",
                        required=True,
                        dest="mcfold_output_dir",
                        help="MC-Fold/MC-FlashFold output dir")
    parser.add_argument('--out_dir', action="store", required=True, dest="out_dir")

    ns = parser.parse_args()

    digested_data = ns.digested_data
    mcfold_output_dir = ns.mcfold_output_dir
    out_dir = ns.out_dir

    list_digested_data = None

    with open(digested_data, 'rb') as dd:
        list_digested_data = cPickle.load(dd)

    for hairpin_dict in list_digested_data:
        hairpin_name = hairpin_dict['name']
        hairpin_acc = hairpin_dict['accession']
        hairpin_seq = hairpin_dict['sequence']
        mcfold_output = os.path.join(mcfold_output_dir, hairpin_acc)

        if not os.path.exists(mcfold_output):
            print "could not find " + mcfold_output
            continue

        mature_5p_range = []
        mature_3p_range = []
        for mature in hairpin_dict['matures']:
            if mature.get("alternative_name", mature["name"]).endswith("5p"):
                start = hairpin_seq.find(mature["sequence"])
                mature_5p_range = range(start, start + len(mature["sequence"]))
            else:
                start = hairpin_seq.find(mature["sequence"])
                mature_3p_range = range(start, start + len(mature["sequence"]))

        list_good_line = []
        list_past_line = []
        with open(mcfold_output, 'rb') as mcfold_o:
            for line in mcfold_o:
                stripped = line.strip()
                if stripped and stripped not in list_past_line:
                    list_past_line.append(stripped)
                    structure = stripped.split()[0]
                    if validate_structure(structure, range_5p=mature_5p_range, range_3p=mature_3p_range):
                        list_good_line.append(stripped)

        with open(os.path.join(out_dir, hairpin_acc), 'wb') as filtered_f:
            filtered_f.write("\n".join(list_good_line))